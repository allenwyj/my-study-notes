# 数组 - Array

![%E6%95%B0%E7%BB%84%20-%20Array%20a3f7168ce01b47af975c6c7cf40cb894/Untitled.png](%E6%95%B0%E7%BB%84%20-%20Array%20a3f7168ce01b47af975c6c7cf40cb894/Untitled.png)

- 高级数据语言中数组内的元素类型目前无严格要求 - 范型。
- 每次申请数组的时候，计算机都会在内存中专门开辟一段连续的地址，每一个地址都可以通过内存管理器访问。

    访问时间快

    - 访问任意一个地址的时间复杂度都是一致的 O(1)

    缺点

    - 需要相应操作才能操作数组

# 对数组的操作

![%E6%95%B0%E7%BB%84%20-%20Array%20a3f7168ce01b47af975c6c7cf40cb894/Untitled%201.png](%E6%95%B0%E7%BB%84%20-%20Array%20a3f7168ce01b47af975c6c7cf40cb894/Untitled%201.png)

- 插入操作需要向后移动后面的元素，再完成插入。这个移动的操作造成了时间复杂度的提高，平均来说需要挪动一半的元素，时间复杂度为O(n)

![%E6%95%B0%E7%BB%84%20-%20Array%20a3f7168ce01b47af975c6c7cf40cb894/Untitled%202.png](%E6%95%B0%E7%BB%84%20-%20Array%20a3f7168ce01b47af975c6c7cf40cb894/Untitled%202.png)

- 同理，删除操作需要先拿出，再将剩余的元素往前移动一个位置。同时在最末端产生了一个空位，需要做一定的内存回收机制。

以Java的数组为例，其源代码在对数组增加元素时，进行的操作是对于元素多的数组，需要做较多的老数组复制，然后创建一个新的数组将值放入，这无意使得其时间复杂度增加。

链表（Linked List）是为了解决这个问题。